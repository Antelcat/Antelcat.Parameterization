using System.Collections.Generic;
using Antelcat.Parameterization.SourceGenerators.Utils;
using Microsoft.CodeAnalysis;

namespace Antelcat.Parameterization.SourceGenerators.Generators;

public class ConvertersGenerator
{
	public IReadOnlyDictionary<ITypeSymbol, string> ConvertersMap => convertersMap;
	
	private readonly Dictionary<ITypeSymbol, string> convertersMap = new(SymbolEqualityComparer.Default);
	private readonly SourceStringBuilder converterBuilder = new(initialIndentCount: 2);
	
	private string GetConverterName(ITypeSymbol typeSymbol)
	{
		var converterName = typeSymbol.Name;
		if (convertersMap.ContainsValue(converterName))
		{
			var i = 1;
			while (convertersMap.ContainsValue(converterName + i))
			{
				i++;
			}
			converterName += i;
		}

		convertersMap.Add(typeSymbol, converterName);
		return converterName;
	}

	public void AddConverter(ITypeSymbol type, string initializer)
	{
		converterBuilder.AppendLine(
			$"public static {Global.TypeConverter} {GetConverterName(type)}Converter {{ get; }} = {initializer};");
	}

	public void Execute(in SourceProductionContext context)
	{
		if (convertersMap.Count == 0) return;
		
		context.AddSource($"{Global.Namespace}.Converters.g.cs", 
			$$"""
			  // <auto-generated/>
			  #nullable enable
			  using System;
			  
			  namespace Antelcat.Parameterization
			  {
			      public static class Converters
			      {
			  {{converterBuilder}}
			      }
			  }
			  """);
	}
}