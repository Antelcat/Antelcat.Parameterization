using Microsoft.CodeAnalysis;

namespace Antelcat.Parameterization.SourceGenerators.Generators;

[Generator]
public class CommonGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context)
	{

	}

	public void Execute(GeneratorExecutionContext context)
	{
		context.AddSource($"{Global.Namespace}.Common.g.cs",
			$$""""
			// <auto-generated/>
			#nullable enable
			using System;
			using System.Collections.Generic;
			using System.Text.RegularExpressions;

			namespace Antelcat.Parameterization
			{
				public class CommandNotFoundException(string commandName) : Exception($"Command \"{commandName}\" not found.") { }
				
				public struct ParsedArgument
				{
					public string Name { get; }
					
					public object? Value { 
						get => value;
						set 
						{
							this.value = value;
							hasValue = true;
						}
					}
					
					public bool HasValue => hasValue;
					
					private object? value;
					private bool hasValue;
					
					public ParsedArgument(string name)
					{
						Name = name;
					}
				}
			
				public static class Common
				{
					public static Regex CommandRegex { get; } = new Regex(@"[^\s""]+|""([^""]|(\\""))*""");
					public static Regex ArgumentRegex { get; } = new Regex(@"[^,""]+|""([^""]|(\\""))*""");
					public static Regex QuotationRegex { get; } = new Regex(@"^""|""$");
				
					internal static int FindIndexOf<T>(this IReadOnlyList<T> list, Predicate<T> predicate) {
						for (var i = 0; i < list.Count; i++) {
							if (predicate(list[i])) {
								return i;
							}
						}
			
						return -1;
					}
			
					/// <param name="arguments"></param>
					/// <param name="parameterNames"></param>
					/// <param name="argumentConverters"></param>
					/// <exception cref="ArgumentException"></exception>
					public static ParsedArgument[] ParseArguments(
						IReadOnlyList<string> arguments,
						IReadOnlyList<(string fullName, string? shortName)> parameterNames,
						IReadOnlyList<string?> defaultValues,
						IReadOnlyList<{{Global.TypeConverter}}> argumentConverters)
					{
						var results = new ParsedArgument[parameterNames.Count];
						for (var i = 0; i < results.Length; i++)
						{
							results[i] = new ParsedArgument(parameterNames[i].fullName);
						}
			
						var isNamedArgumentUsed = false;
						for (var i = 1; i < arguments.Count; i++)
						{
							var argumentIndex = -1;
							var argument = arguments[i];
							
							if (argument.StartsWith("--"))
							{
								argument = argument[2..];
								argumentIndex = parameterNames.FindIndexOf(x => x.fullName == argument);
								if (argumentIndex == -1)
								{
									throw new ArgumentException($"Argument \"--{argument}\" not found.");
								}
								isNamedArgumentUsed = true;
							}
							else if (argument.StartsWith('-'))
							{
								argument = argument[1..];
								argumentIndex = parameterNames.FindIndexOf(x => x.shortName == argument);
								if (argumentIndex == -1)
								{
									throw new ArgumentException($"Argument \"-{argument}\" not found.");
								}
								isNamedArgumentUsed = true;
							}
							else if (isNamedArgumentUsed)
							{
								throw new ArgumentException("Named results must come after all anonymous results.");
							}
							
							if ((argumentIndex != -1 && results[argumentIndex].HasValue) || 
								(argumentIndex == -1 && results[i - 1].HasValue))
							{
								throw new ArgumentException($"Argument \"{argument}\" is duplicated.");
							}
			
							if (argumentIndex != -1)
							{
								// 当前是命名参数，那么下一个才是参数的值
								if (i == arguments.Count - 1 || arguments[i + 1].StartsWith('-'))
								{
									// 如果没有下一个参数，或者下一个参数是命名参数
									if (defaultValues[argumentIndex] == null)
									{
										throw new ArgumentException($"The value of argument \"{argument}\" is not specified.");
									}
									
									results[argumentIndex].Value = argumentConverters[argumentIndex].ConvertFromString(defaultValues[argumentIndex]);
									continue;
								}
			
								argument = arguments[++i];
							}
							else
							{
								argumentIndex = i - 1;
							}
			
							results[argumentIndex].Value = argumentConverters[argumentIndex].ConvertFromString(argument);
						}
			
						return results;
					}
					
					public static T ConvertArgument<T>(ParsedArgument parsed)
					{
						if (!parsed.HasValue) throw new ArgumentException($"Argument \"{parsed.Name}\" is not specified.");
						return parsed.Value is T result ? result : throw new ArgumentException($"Argument \"{parsed.Name}\" is not of type {typeof(T).FullName}.");
					}
					
					public static T ConvertArgument<T>(ParsedArgument parsed, T defaultValue) 
					{
						if (!parsed.HasValue) return defaultValue;
						return parsed.Value is T result ? result : throw new ArgumentException($"Argument \"{parsed.Name}\" is not of type {typeof(T).FullName}.");
					}
				}
			}
			"""");
	}
}