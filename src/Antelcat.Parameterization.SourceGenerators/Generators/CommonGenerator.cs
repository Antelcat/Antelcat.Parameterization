using Microsoft.CodeAnalysis;

namespace Antelcat.Parameterization.SourceGenerators.Generators;

[Generator]
public class CommonGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context)
	{

	}

	public void Execute(GeneratorExecutionContext context)
	{
		context.AddSource($"{Global.Namespace}.Common.g.cs",
			$$""""
			// <auto-generated/>
			#nullable enable
			using System;
			using System.Collections.Generic;

			namespace Antelcat.Parameterization
			{
				public class CommandNotFoundException(string commandName) : Exception($"Command \"{commandName}\" not found.") { }
			
				public static class Utils
				{
					internal static int FindIndexOf<T>(this IReadOnlyList<T> list, Predicate<T> predicate) {
						for (var i = 0; i < list.Count; i++) {
							if (predicate(list[i])) {
								return i;
							}
						}
			
						return -1;
					}
			
					/// <param name="commandAndArguments"></param>
					/// <param name="parameterNames"></param>
					/// <param name="isParameterBoolean"></param>
					/// <param name="argumentConverters"></param>
					/// <exception cref="ArgumentException"></exception>
					public static object?[] ParseArguments(
						IReadOnlyList<string> commandAndArguments,
						IReadOnlyList<(string fullName, string? shortName)> parameterNames,
						IReadOnlyList<bool> isParameterBoolean,
						IReadOnlyList<{{Global.TypeConverter}}> argumentConverters)
					{
						var arguments = new object?[parameterNames.Count];
			
						var isNamedArgumentUsed = false;
						for (var i = 1; i < commandAndArguments.Count; i++)
						{
							var argumentIndex = -1;
							var argument = commandAndArguments[i];
			
							if (argument.StartsWith("--"))
							{
								argument = argument[2..];
								argumentIndex = parameterNames.FindIndexOf(x => x.fullName == argument);
								if (argumentIndex == -1)
								{
									throw new ArgumentException($"Argument \"--{argument}\" not found.");
								}
								isNamedArgumentUsed = true;
							}
							else if (argument.StartsWith('-'))
							{
								argument = argument[1..];
								argumentIndex = parameterNames.FindIndexOf(x => x.shortName == argument);
								if (argumentIndex == -1)
								{
									throw new ArgumentException($"Argument \"-{argument}\" not found.");
								}
								isNamedArgumentUsed = true;
							}
							else if (isNamedArgumentUsed)
							{
								throw new ArgumentException("Named arguments must come after all anonymous arguments.");
							}
			
							if (argumentIndex != -1)
							{
								// 当前是命名参数，那么下一个才是参数的值
								if (i == commandAndArguments.Count - 1 || commandAndArguments[i + 1].StartsWith('-'))
								{
									// 如果没有下一个参数，或者下一个参数是命名参数
									if (!isParameterBoolean[argumentIndex])
									{
										// 如果当前参数不是bool，那么就是缺少值
										throw new ArgumentException("Named argument must be followed by a value except bool.");
									}
			
									arguments[argumentIndex] = true;
									continue;
								}
			
								argument = commandAndArguments[++i];
							}
							else
							{
								argumentIndex = i - 1;
							}
			
							arguments[argumentIndex] = argumentConverters[argumentIndex].ConvertFromString(argument);
			
							// if (parameterType.IsGenericType && parameterType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
							// {
							// 	var parts = new List<object?>();
							// 	foreach (Match match in Regex.Matches(argument, @"[^,""]+|""([^""]|(\\""))*"""))
							// 	{
							// 		parts.Add(ConvertArgument(Regex.Replace(match.Value, @"^""|""$", "").Replace("\\\"", "\"")));
							// 	}
							//
							// 	// TODO: 构造参数类型的数组并传参
							// }
							// else
							// {
							// 	arguments[argumentIndex] = ConvertArgument(argument);
							// }
							//
							// object? ConvertArgument(string argumentString)
							// {
							// 	if (attributes[argumentIndex] is { Converter: not null } argumentAttribute)
							// 	{
							// 		if (Activator.CreateInstance(argumentAttribute.Converter) is not StringConverter converter)
							// 		{
							// 			throw new ArgumentException(
							// 				$"Converter \"{argumentAttribute.Converter}\" must derive from System.ComponentModel.StringConverter.");
							// 		}
							// 		return converter.ConvertFromString(argumentString);
							// 	}
							//
							// 	if (parameterType == typeof(string))
							// 	{
							// 		return argumentString;
							// 	}
							//
							// 	return TypeDescriptor.GetConverter(parameterType.ParameterType).ConvertFromString(argumentString);
							// }
						}
			
						return arguments;
					}
				}
			}
			"""");
	}
}